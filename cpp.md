# C/C++芝士点

## 知名函数

### :star:lower_bound

`lower_bound(a,a+n,val,less<T>())`在一个左闭右开的有序区间里进行**二分查找**，用法和`upper_bound()`相似。默认为递增顺序。如果第四个参数传入`greater<T>()`，则定义为递减排序。那么`upper_bound`则返回指向*被查值*<*查找值*的最小指针，`lower_bound`则返回指向 被查值 $\leq$ 查找值 的最小指针。

``` cpp
lower_bound() return pointer *(a+x)
{lower_bound()-a} return offset inx
```

PS ：set使用标准库的lower_bound()时间复杂度为 $ O(\log{n})+n$，应该用STL函数自带的实现，如 `map.lower_bound (key)`

### substr

```cpp
函数原型：string substr (size_t pos = 0, size_t len = npos) const;
```

产生子串，返回一个新建的 初始化为string对象的子串的拷贝string对象。子串是源对象从字符位置`pos`开始，跨越`len`个字符（或直到字符串的结尾，以先到者为准）的部分。
前段子串：$substr(0,pos)$，后段子串：$substr(pos+1)$。

### string.find

```cpp
函数原型：size_type find(const string & str, size_type pos = 0) const
```

从字符串的`pos`位置开始，查找子字符串`str`。如果找到，则返回该子字符串首次出现时其首字符的索引；否则，返回string::npos，**`string::npos`** 是字符串的结尾位置。
判断条件：$string.find(target)\neq string::npos$

- **rfind()** 查找子字符串或字符**最后一次**出现的位置
- **find_first_of()** 在字符串中查找**参数任何一个字符***首次*出现的位置
- **find_last_of()** 同上，在字符串中查找参数中任何一个字符*最后一次*出现的位置

### vector.insert

- **`iterator insert(pos, elem)`** 在迭代器 pos 指定的位置之前插入一个新元素elem，并返回表示新插入元素位置的迭代器。
- **`iterator insert(pos, n, elem)`** 在迭代器 pos 指定的位置之前插入 n 个元素 elem，并返回表示第一个新插入元素位置的迭代器。
- **`iterator insert(pos, first, last)`**  在迭代器 pos 指定的位置之前，**插入其他容器**（不仅限于vector）中位于 $[first,last)$ 区域的所有元素，并返回表示第一个新插入元素位置的迭代器。
- **`iterator insert(pos, initlist)`** 在迭代器 pos 指定的位置之前，插入初始化列表（用大括号{}括起来的多个元素，中间有逗号隔开）中所有的元素，并返回表示第一个新插入元素位置的迭代器。

#### insert与emplace

- **`iterator emplace (const_iterator pos, args...)`**  pos 为指定插入位置的迭代器，**args... 表示与新插入元素的构造函数相对应的多个参数**，`emplace()` 每次**只能插入一个元素**，而不是多个。C++11 标准新增，变参模板 和 完美转发。
- `emplace()` 插入元素时，在容器的指定位置直接构造元素，不产生临时变量。`insert()` 先单独生成，再将其复制（或移动）到容器中。
- `insert()` 优先调用移动构造函数，`emplace()`只需要调用构造函数，`emplace()`效率更高。

### sort

- **`sort (first, last)`** 对容器或普通数组中 $[first, last)$ 范围内的元素进行排序，默认进行升序排序。
- **`stable_sort (first, last)`** 和 sort() 函数功能相似，不同之处在于，对于 $[first, last)$ 范围内值相同的元素，该函数不会改变它们的相对位置。
- **`partial_sort (first, middle, last)`** 从 $[first,last)$ 范围内，筛选出 $middle-first$ 个最小的元素并排序存放在 $[first，middle)$ 区间中。

### all_of & none_of & all_of

- **`all_of(first, last, pred)`** 测试范围内**所有**元素的条件，`pred`为一元函数
- **`none_of(first, last, pred)`** 测试**没有**元素满足条件
- **`any_of(first, last, pred)`** 测试范围内**任何**元素是否满足条件

### 赋值与拷贝

- `A a; A b=a;`为拷贝构造函数，b未初始化，等同于`A b(a);`浅拷贝，可重写`A(const A&){}`实现逻辑。
- `A a,b; b=a;`为赋值运算符重载，此时b已初始化。

### extern "C"

加上extern "C"后，**会指示编译器这部分代码按C语言（而不是C++）的方式进行编译**。由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而**C语言并不支持函数重载**，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名。

extern申明的函数和变量可以在**本模块或其他模块**中使用。对应的关键字是static，static表明变量或者函数只能在本模块中使用，因此，被static修饰的变量或者函数不可能被extern C修饰。

## Lambda 表达式

Lambda 表达式，实际上就是提供了一个类似**匿名函数**的特性，而匿名函数则是在需要一个函数，但是又不想费力去命名一个函数的情况下去使用的。

```cpp
基本语法：[ caputrue ] ( params ) opt -> ret { body; };
```

1) `capture` 是捕获列表；控制了lambda表达式能够访问的**外部变量**，以及如何访问这些变量。
2) `params` 是参数表；(选填)
3) `opt` 是函数选项；可以填mutable,exception,attribute（选填）
   - `mutable` 说明lambda表达式体内的代码可以修改被捕获的变量，并且可以访问被捕获的对象的non-const方法。
   - `exception` 说明lambda表达式是否抛出异常以及何种异常。
   - `attribute` 用来声明属性。
4) `ret` 是返回值类型（拖尾返回类型）。(选填)
5) `body` 是函数体。

### 捕获列表

- `[]` 不捕获任何变量。
- `[&]` 捕获外部作用域中所有变量，并**作为引用**在函数体中使用（**按引用捕获**）。
- `[=]` 捕获外部作用域中所有变量，并**作为副本**在函数体中使用(**按值捕获**)。
  - 注意值捕获的前提是变量可以拷贝，且被捕获的变量在 lambda 表达式**被创建时拷贝**，而非调用时才拷贝。如果希望lambda表达式在调用时能即时访问外部变量，我们应当使用引用方式捕获。
  - 如果希望去**修改**按值捕获的外部变量，需要**显示指明**lambda表达式为`mutable`。被`mutable`修饰的lambda表达式就算没有参数也要写明参数列表。
- `[=,&foo]` 按值捕获外部作用域中所有变量，并按引用捕获foo变量。
- `[bar]` 按值捕获bar变量，同时不捕获其他变量。
- `[this]` 捕获当前类中的this指针，让lambda表达式拥有和当前类成员函数同样的访问权限。如果已经使用了&或者=，就默认添加此选项。捕获this的目的是可以在lamda中**使用当前类的成员函数和成员变量**。

### 大致原理

每当你定义一个lambda表达式后，编译器会**自动生成一个匿名类**（这个类重载了()运算符），我们称为**闭包类型（closure type）**。那么在运行时，这个lambda表达式就会返回一个匿名的闭包实例，是一个**右值**。所以，我们上面的lambda表达式的结果就是一个个闭包。**对于复制传值捕捉方式，类中会相应添加对应类型的非静态数据成员**。在运行时，会用复制的值初始化这些成员变量，从而生成闭包。对于引用捕获方式，无论是否标记mutable，都可以在lambda表达式中修改捕获的值。

### 无用单元

指一块存储区（或资源），该存储区虽然是程序（或进程）的一部分，但是在程序中却不可再对其引用。
按照C++的规定，我们可以说，无用单元是程序中没有指针指向的某些资源。

```cpp
int main() {
    char *p = new char[1000];//分配一个包含1000个字符的动态数组
    char *q = new char[1000];//另一个动态内存
    p = q;//将p和q进行一些操作的代码
    /*此时，p和q指向相同的区域，没有指针指向之前p指向的旧存储区！
    该存储区还在，仍然占用着空间。但是程序已经不能访问该区域*/
}
```

#### C++在何时产生无用单元

1. 从函数退出时，在函数内部创建的所有局部变量（包括对象）以及按值传递的所有参数都不可访问。
2. 从块退出时，在块内部声明的所有局部变量（包括对象）都不可访问。
3. 任何复杂表达式包含的临时变量，在不需要时必须全部予以销毁，否则它们将成为无用单元。
4. 任何动态分配的对象，在不需要时必须由程序员显式地销毁。

### 悬挂引用

当两个指针同时指向一个地址时，通过一个指针删除了该地址的数据，另一个指针就产生了悬挂引用。

### 引用坍缩

无论模板参数是什么类型的引用，当且仅当实参类型为右引用时，模板参数才能被推导为右引用类型。

## :star:智能指针

### unique_ptr

`unique_ptr` 和指定对象的内存空间紧密绑定，不允许与其他 `unique_ptr` 指针共享同⼀个对象内存。即**内存所有权在同⼀个时间内是唯⼀的**，无法进行复制构造，**无法进行复制赋值操作**。但 「所有权」 可以通过 move 和**移动语义**进⾏来实现转移。

```cpp
unique_ptr<int> p1(new int(1));
unique_ptr<int> p2 = p1;        // ⾮法，不可共享内存所有权
unique_ptr<int> p3 = move(p1);  // 合法，移交所有权。p1 将丧失所有权
p3.reset();                     // 显式释放内存
```

### shared_ptr

与 `unique_ptr` 相对，可以共享内存所有权，即多个 `shared_ptr 可以指向同⼀个对象的内存。同时采⽤**引用计数法**来判断内存是否还被需要，从⽽判断是否需要进⾏回收。

```cpp
shared_ptr<int> p4(new int(2));
shared_ptr<int> p5 = p4;  // 合法
p4.reset();               // 由于采⽤引⽤计数法，p4.reset() 仅仅使得引⽤数减⼀
cout << *p5 << endl;      // 所指向的内存由于仍有 p5 所指向，所以不会被回收，访问 *p5 是合法且有效的 
                          // 输出 2
```

### weak_ptr

`weak_ptr` 可以指向 `shared_ptr` 指向的内存，且在必要时可以通过成员 lock 来返回⼀个指向当前内存的 `shared_ptr` 指针，如果当前内存已经被释放，那么将 lock() 返回 nullptr。⽽另⼀个重点则是 `weak_ptr` **不参与引用计数**。如同⼀个「虚拟指针」⼀样指向 `shared_ptr` 指向的对象内存，⼀⽅⾯不妨碍内存的释放，另⼀⽅⾯又可以通过 `weak_ptr` 判断内存是否有效以及是否已经被释放。

- `weak_ptr` 可以解决 `shared_ptr` 引用计数法**循环引用**的问题

```cpp
shared_ptr<int> p6(new int(3));
shared_ptr<int> p7 = p6;
weak_ptr<int> weak_p8 = p7;
shared_ptr<int> p9_from_weak_p8 = weak_p8.lock();   //lock()返回⼀个指向当前内存的 shared_ptr 指针
if (p9_from_weak_p8 != nullptr) {
  cout << "内存有效" << endl;
} else {
  cout << "内存已被释放" << endl;
}
p6.reset();
p7.reset(); // weak_p8
// 内存已被释放，即使 weak_p8 还「指向」该内存
```

### this 指针

this指针是存在于类的成员函数中,指向被调用函数所在的**类实例的地址**

- 一个对象的this指针并不是对象本身的一部分，不会影响sizeof(对象)的结果。
- this作用域是在类内部，当在类的非静态成员函数中访问类的非静态成员的时候，编译器会自动将对象本身的地址作为一个隐含参数传递给函数。即使你没有写上this指针，编译器在编译的时候也是加上this的，它作为**非静态成员函数的隐含形参**，对各成员的访问均通过this进行。
- 在成员函数内部，我们可以直接使用调用该函数的对象的成员，而无需通过成员访问运算符来做到这一点，因为this所指的正是这个对象。任何对类成员的直接访问都被看成this的隐式使用。
- this的目的总是指向这个对象，所以this是一个**常量指针**，我们不允许改变this中保存的地址

### const与重载

- 在类外定义的函数，若参数不是传址，则编译报错；
- 在类内定义的函数，若参数不是传址，则只调用无const的函数；
- 在类外和类内定义的函数，若参数是传址，重载规则如下：
    1. const重载主要是通过能否对传入的参数进行修改为判断的。
    2. const参数重载和const函数重载机制（const函数重载机制即，在函数后加const）都是一样的，因为对于const 函数重载可看做是**对隐含的指针this的参数重载**。

## 虚函数表

为了支持虚函数机制，编译器为每一个拥有虚函数的类创建了一个**虚函数表（virtual table）**，这个表中有许多的**槽（slot）**，每个槽中存放的是虚函数的地址。对象的内存地址（&a）所指向的内存中的**前四个字节中存放的是该对象的虚函数表的首地址**。虚函数表解决了继承、覆盖、添加虚函数的问题，保证其真实反应实际的函数。
**注：一个虚函数表对应一个虚函数类，不是类的对象！**

### 单继承

- 无虚函数覆盖
  - *父类函数实体* 的**地址**被拷贝到 *子类实例* 的虚函数表对应的 slot 之中。
  - 新增的 虚函数 置于虚函数表的**后面**，并按声明**顺序存放**。
- 有虚函数覆盖
  - 相比于无覆盖的情况，只是把 子类函数 覆盖了父类函数，即第一个槽的函数地址发生了变化，其他的没有变化。

### 多继承

- 无虚函数覆盖
  - **每个基类子对象对应一个虚函数表**。
  - 派生类中新增的虚函数放到**第一个**虚函数表的后面。
- 有虚函数覆盖
  - 与单继承相似，覆盖每个基类子对象被重写的函数

### 虚表指针初始化顺序

1. 分配内存
2. 基类构造过程（如果为派生类）
3. 初始化子类虚表指针
4. 子类列表初始化
5. 执行子类构造函数体

### 类初始化列表的使用

- 需要初始化的数据成员是对象的情况；
- 需要初始化**const修饰**的类成员或初始化**引用**成员数据；
- 子类初始化父类的私有成员；

## :star:文件编译

- **预处理阶段**：处理以 # 开头的预处理命令，得到不包含 # 指令的.i文件。
- **编译阶段**：翻译成汇编文件，将.i文件转化位.s文件。
- **汇编阶段**：将汇编文件翻译成可重定位目标文件（目标机器指令），将.s文件转化成.o文件。
- **链接阶段**：将可重定位目标 .o 文件和 printf.o 等单独预编译好的目标文件进行合并，得到最终的可执行目标文件。
![编译过程](asset/编译过程.jpg)

目标文件由段组成，通常至少有两个段：

- 代码段：包换主要程序的指令。该段是可读和可执行的，一般不可写
- 数据段：存放程序用到的全局变量或静态数据。可读、可写、可执行。

## C++ 内存分配

按区分：代码区、全局/静态区、常量区、堆栈区

**代码区**：存放程序的代码，即CPU执行的机器指令，一般只读。
**静态区**（全局区）：存放静态变量和全局变量。
**常量区**：存放常量(程序在运行的期间不能够被改变的量，例如: 10，字符串常量”abcde”， 数组的名字等)
**堆区**：由程序员调用malloc()函数来主动申请的，需使用free()函数来释放内存。
**栈区**：存放函数内的局部变量，形参和函数返回值。

### 对象析构释放顺序

`delete`主动释放 $\Rightarrow$ 局部变量 $\Rightarrow$ 局部静态变量 $\Rightarrow$ 全局变量

## 内存泄漏

1. malloc和free未成对出现，或不匹配使用 new[] 和 delete[]
2. 通过局部分配的内存，未在调用者函数体内释放
3. 没有将基类的析构函数定义为虚函数，当基类的指针指向子类时，delete该对象不会调用子类的析构函数
4. 由于程序运行时出现不可遇见的错误，导致内存泄漏。
