# 面试芝士点

## ORM

**对象关系映射（Object Relational Mapping）模式是一种为了解决面向对象与关系数据库存在的互不匹配现象的技术**。把对象模型表示的对象映射到基于SQL的关系模型数据库结构中去。简单的说，ORM是通过使用描述对象和数据库之间映射的元数据，将程序中的对象自动持久化到关系数据库中。Java典型的ORM中间件有:Hibernate、ibatis、speedframework。
**优点**：开发效率更高、数据访问更抽象、轻便、支持面向对象封装。
**缺点**：降低程序的执行效率、思维固定化。

## 负载均衡

负载均衡（Load Balance）其意思就是分摊到多个操作单元上进行执行，例如Web服务器、FTP服务器、企业关键应用服务器和其它关键任务服务器等，从而共同完成工作任务。
负载均衡建立在现有网络结构之上，它提供了一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。

## CDN

**内容分发网络（Content Delivery Network）**,使用户可就近取得所需内容，解决Internet网络拥挤的状况，提高用户访问网站的响应速度。提升网站的稳定性和安全性。
关键技术：内容路由技术、内容分发技术、内容存储技术、内容管理技术

### 内容路由功能

- CDN的负载均衡系统实现CDN的内容路由功能。CDN内容路由功能作用使用户请求到达CDN网络中的最佳节点
- **全局负载均衡**主要目的是让用户的请求到达CDN网络中最近的节点
  - 用户发送一个请求,智能DNS会向所有的节点发送一个探测指令,节点收到探测指令以后会主动判断自己和目标之间的距离,然后将探测的结果反馈给智能DNS,由智能DNS进行判断,最后返回综合评分最高的节点地址
- **局部负载均衡**在特定的范围内寻找一台合适的节点提供服务（要考虑到节点的健康性、负载情况、支持的媒体格式等运行状态）

### 内容分发技术

- PUSH是一种主动分发的技术，通常由内容管理系统发起，将内容从源或者中心媒体资源库发布到各个边缘的Cache节点（HTTP/FTP）
- PULL 是一种被动的分发技术，当用户请求的内容不在请求所达到的边缘Cache的节点上时，该节点会从内容源或其他节点PULL下所需的内容（按需分发）

### 内容存储技术

- 内容源的存储通常采用海量存储架构（内容的规模及吞吐量较大）
- Cache节点的存储：
功能上，对各种内容格式的支持、对部分缓存的支持
性能上，容量大小，吞吐率、可靠性及稳定性

### 内容管理技术

本地内容管理（对Cache节点而言）的目标是提高内容服务的效率，提高本地节点的存储利用率。

- 本地内容索引是实现基于内容感知调度的关键
- 本地内容的复制。通常为了提高存储的效率，同一个内容只在某个特定的节点中存储一份，当对该内容的访问超过这个节点的能力范围，就将该内容进行分发到其他节点上
- 本地内容访问状态的收集。搜集各个节点上各个内容访问的统计信息，节点可用服务能力及内容变化的情况

## 哈希函数的构造

### 数字分析法

事先知道关键字集合，并且每个关键字的位数比哈希表的地址码位数多时，可以从关键字中选出分布较均匀的若干位，构成哈希地址

### 平方取中法

当无法确定关键字中哪几位分布较均匀时，可以先求出关键字的平方值，然后按需要取平方值的中间几位作为哈希地址。

### 分段叠加法

按哈希表地址位数将关键字分成位数相等的几部分（最后一部分可以较短），然后将这几部分相加，舍弃最高进位后的结果就是该关键字的哈希地址。具体方法有折叠法与移位法。

### 除留余数法

假设哈希表长为m，p为小于等于m的最大素数，则哈希函数为 $h（k）=k \pmod p$

### 伪随机数法

采用一个伪随机函数做哈希函数，$h(key)=random(key)$

## 哈希冲突的解决

### 开放定址法

在遇到哈希冲突时，去寻找一个新的空闲的哈希地址。

- **线性探测法**：向后一直加1并对m取模直到存在一个空余的地址供存放
  - 公式： $h(x)=(Hash(x)+i)\pmod {Hashtable.length};i++;$
  - 存在问题：
    - 出现非同义词冲突（两个不相同的哈希值，抢占同一个后续的哈希地址）存入哈希表的记录连成一片，出现堆积或聚集现象。
    - 哈希表删除工作非常困难。假如要从哈希表 HT 中删除一个记录，按理应将这个记录所在位置置为空，但我们不能这样做，而只能**标上已被删除的标记**，否则将会影响以后的查找。
    - 处理溢出需另编程序。一般可另外设立一个**溢出表**，专门用来存放上述哈希表中放不下的记录。
- **线性补偿探测法**：将线性探测的步长从 1 改为 Q，且要求 Q 与 m 互质
  - 公式： $h(x)=(Hash(x)+Q)\pmod {Hashtable.length};Q+=Q;$
- **平方探测法**（二次探测）：前后寻找
  - 公式： $h(x)=(Hash(x) +i)\pmod {Hashtable.length};i=\pm i^2;$
- **随机探测法**：线性探测的步长从常数改为随机数
  
### 再哈希法

同时构造多个不同的哈希函数，等发生哈希冲突时就使用第二个、第三个……等其他的哈希函数计算地址，直到不发生冲突为止。虽然不易发生聚集，但是增加了计算时间。

### 链地址法（拉链法）

将所有哈希地址相同的记录都链接在同一链表中。
公式： $h(x)=x \pmod {Hashtable.length};$

- 处理冲突简单，且无堆积现象
- 由于拉链法中各链表上的结点空间是动态申请的，故它更适合于造表前无法确定表长的情况
- 结点较大时拉链法中增加的指针域可忽略不计，节省空间
- 用拉链法构造的散列表中，删除结点的操作易于实现。只要简单地删去链表上相应的结点即可。
- 缺点：

### 建立公共溢出区

将哈希表分为基本表和溢出表，将发生冲突的都存放在溢出表中

## 如何提高系统QPS？

### 增加并发数

1.比如增加tomcat并发的线程数，服务器性能匹配的线程数，可以更多满足服务请求。
2.增加数据库的连接数，预建立合适数量的TCP连接数
3.后端服务尽量无状态化，可以更好支持横向扩容，满足更大流量要求
4.调用链路上的各个系统和服务尽量不要单点，要从头到尾都是能力对等的，不能让其中某一点成为瓶颈。
5.RPC调用的尽量使用线程池，预先建立合适的连接数。

### 减少平均响应时间

1.请求尽量越前结束，越好，这样压力就不要穿透到后面的系统上，可以在各个层上加上缓存
2.流量消峰。放行适当的流量，处理不了的请求直接返回错误或者其他提示。和水坝道理很类似
3.减少调用链
4.优化程序
5.减少网络开销，适当使用长连接
6.优化数据库，建立索引

## :star: 高并发高负载的优化方法

- HTML静态化
  - 对于系统中频繁使用数据库查询但是内容更新很小的应用，可以考虑将这部分内容进行后台更新的时候进行静态化，这样避免了大量的数据库访问请求。
- 图片服务器分离
  - 把图片单独存储，尽量减少图片等大流量的开销。
- 数据库集群和分库分表
  - 读写分离、主从复制，数据库集群等。尽量减少数据库的访问，可以使用缓存数据库如memcache、redis。
- 缓存
- 镜像
  - 尽量减少下载，可以把不同的请求分发到多个镜像端。
- 负载均衡
  - 扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力，同时能够提高网络的灵活性和可用性。

## :star:Java 与 C++ 区别

- Java 是纯粹的面向对象语言，所有的对象都继承自 java.lang.Object，C++ 为了兼容 C 即支持面向对象也支持面向过程。
- Java 通过虚拟机从而实现跨平台特性，但是 C++ 依赖于特定的平台。
- Java 没有指针，它的引用可以理解为安全指针，而 C++ 具有和 C 一样的指针。
- Java 支持自动垃圾回收，而 C++ 需要手动回收。
- Java 不支持多重继承，只能通过实现多个接口来达到相同目的，而 C++ 支持多重继承。
- Java 不支持操作符重载，虽然可以对两个 String 对象执行加法运算，但是这是语言内置支持的操作，不属于操作符重载，而 C++ 可以。
- Java 的 goto 是保留字，但是不可用，C++ 可以使用 goto。

## 场景题

### 如何从 5 亿个数中找出中位数？

**双堆法**：维护两个堆，一个大顶堆，一个小顶堆。大顶堆中最大的数**小于等于**小顶堆中最小的数；保证这两个堆中的元素个数的差不超过 1。

若数据总数为**偶数**，当这两个堆建好之后，中位数就是**这两个堆顶元素的平均值**。当数据总数为**奇数**时，根据两个堆的大小，中位数一定在**数据多的堆的堆顶**。

### 海量数据，提取某日访问次数最多的IP？

1. IP地址最多有 $2^{32}=4G$ 种取值情况，所以不能完全加载到内存中处理；
2. 可以考虑采用 “分而治之” 的思想，按照IP地址的 Hash(IP)%1024 值，把海量IP日志分别存储到1024个小文件中。这样每个小文件最多包含4MB个IP地址；
3. 对于每一个小文件，可以构建一个key=IP，value=出现次数的Hash map，同时记录当前出现次数最多的那个IP地址；
4. 可以得到1024个小文件中的出现次数最多的IP，再依据常规排序算法得到总体上出现次数最多的IP。

### 查询最热门的10个查询串？

**Top K算法**：先对这批海量数据预处理，在 $O(N)$ 的时间内用Hash表完成统计。再借助**堆**找出Top K，时间复杂度为$O(N\log K)$。

### 在2.5亿个整数中找出不重复的整数

采用 **2-Bitmap**（每个数分配2bit，00表示不存在，01表示出现一次，10表示多次，11无意义）进行，共需内存2^32 * 2 bit=1 GB。扫描这2.5亿个整数，查看Bitmap中相对应位，如果是00变01，01变10，10保持不变。扫描完成后将 bitmap 对应位是01的整数输出即可。
ps：如果是查找是否存在则用 **bitmap** 进行一位存储。

## OOP设计原则

### 开闭原则 (Open-Closed Principle)

一个软件实体应当对扩展开发，对修改关闭。

### 里氏代换原则 (Liskov Substitution Principle)

### 依赖倒置原则 (Dependence Inversion Principle)

### 单一职责原则 (Simple responsibility pinciple)

### 接口隔离原则 (Interface Segregation Principle)

### 深拷贝与浅拷贝

浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。

## 微服务

### 客户端发现

当服务实例启动的时候，它的网络地址被注册到服务注册中心。当该实例终止的时候，该地址从服务注册中心移除。服务实例的注册通常使用心跳机制定期刷新。**客户端将获得一个提供服务的列表，自己决定去那个访问。**

### 服务器发现

客户端通过负载均衡器向服务发送请求。**负载均衡器查询服务注册中心并路由每个请求到可用的服务实例**。与客户端发现机制一样，服务实例也需要向服务注册中心注册和注销。

## java 概念

### Object 模型

#### PO（persistant object）

持久化对象 与数据库中的表相映射的java对象，跟持久层（通常是关系型数据库）的数据结构形成一一对应的映射关系

#### VO（value object）

通常用于业务层之间的数据传递，和PO一样也是仅仅包含数据而已。但应是抽象出的业务对象，它的作用是把某个指定页面（或组件）的所有数据封装起来。VO代表**展示层需要显示**的数据。

#### DTO（Data Transfer Object）

数据传输对象，展示层与服务层之间的数据传输对象，封装了要传送的批量的数据。DTO代表**服务层需要接收和返回**的数据

#### POJO（plain ordinary java object）

传统意义的 java 对象，最基本的 Java Bean ，只有属性字段及 setter 和 getter 方法

#### DAO（data access object）

负责持久层的操作，为业务层提供接口。此对象用于封装对数据库的访问。通常和 PO 结合使用，DAO 中包含了各种数据库的操作方法。

### JWT（JSON Web Token）

是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准。该token被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。JWT的声明一般被**用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源**，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。

token令牌组成：标头（Header）、有效载荷（Payload）、签名（Signature）

- 授权：一旦用户登录，每个后续请求将包括JWT，从而允许用户访问该令牌允许的路由，服务和资源。它的开销很小并且可以在不同的域中使用。如：单点登录。
- 信息交换：在各方之间安全地传输信息。JWT可进行签名（如使用公钥/私钥对)，因此可确保发件人。由于签名是使用标头和有效负载计算的，因此还可验证内容是否被篡改。

#### 基于session认证所显露的问题

- **Session**：session都是保存在内存中，而随着认证用户的增多，服务端的开销会明显增大。
- **扩展性**：用户下次请求还必须要请求对应服务器上，对于分布式的应用限制了负载均衡器的能力。这也意味着限制了应用的扩展能力。
- **CSRF**：基于cookie来进行用户识别的, cookie如果被截获，用户就会很容易受到跨站请求伪造的攻击。

#### 基于token的鉴权机制的流程

- 用户使用用户名密码来请求服务器
- 服务器进行验证用户的信息
- 服务器通过验证发送给用户一个token
- 客户端存储token，并在每次请求时附送上这个token值
- 服务端验证token值，并返回数据

#### JWT 优点

- 简洁(Compact)：便于传输，可以通过URL，POST参数或者在HTTP header发送，数据量小，传输速度也很快；
- 自包含(Self-contained)：负载中包含了所有用户所需要的信息，避免了多次查询数据库；
- Token是以JSON加密的形式保存在客户端，所以JWT是跨语言的，原则上任何web形式都支持。
- 不需要在服务端保存会话信息，易于应用的扩展，特别适用于分布式微服务。
